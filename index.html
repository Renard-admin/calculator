<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Распознавание жестов, лиц и объектов</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #333;
            color: #fff;
            font-family: sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Зеркальный эффект */
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 4px;
            z-index: 10;
            max-width: 350px;
        }
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        .btn:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .status {
            color: white;
            margin-bottom: 10px;
            text-align: center;
        }
        #detectionToggle {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
        <div class="status" id="loadingStatus">Загрузка моделей...</div>
        <div class="status" id="loadingProgress">0%</div>
    </div>

    <div id="container">
        <!-- Видео с камеры -->
        <video id="video" autoplay playsinline muted></video>
        
        <!-- Canvas слои -->
        <canvas id="objectsLayer"></canvas>
        <canvas id="facesLayer"></canvas>
        <canvas id="handsLayer"></canvas>
        <canvas id="drawLayer"></canvas>
        
        <div id="info">
            <strong>Жесты:</strong>
            <ul>
                <li>два раза сжать/разжать кулак + указательный = начать рисование</li>
                <li>OK (большой + указательный) = очистить</li>
            </ul>
            <div id="detections"></div>
        </div>
        
        <div class="controls">
            <button id="fullscreenBtn" class="btn">Полный экран</button>
            <button id="switchCameraBtn" class="btn">Сменить камеру</button>
            <button id="detectionToggle" class="btn">Распознавание вкл</button>
        </div>
    </div>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <!-- Face-API.js -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <!-- TensorFlow.js and COCO-SSD -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <script>
        // Элементы страницы
        const videoElement = document.getElementById('video');
        const objectsCanvas = document.getElementById('objectsLayer');
        const facesCanvas = document.getElementById('facesLayer');
        const handsCanvas = document.getElementById('handsLayer');
        const drawCanvas = document.getElementById('drawLayer');
        const infoDiv = document.getElementById('info');
        const detectionsDiv = document.getElementById('detections');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const switchCameraBtn = document.getElementById('switchCameraBtn');
        const detectionToggleBtn = document.getElementById('detectionToggle');
        const loadingElement = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');
        const loadingProgress = document.getElementById('loadingProgress');

        // Контексты для рисования
        const objectsCtx = objectsCanvas.getContext('2d');
        const facesCtx = facesCanvas.getContext('2d');
        const handsCtx = handsCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');

        // Переменные состояния
        let currentStream = null;
        let camera = null;
        let currentFacingMode = 'user'; // Начинаем с фронтальной камеры
        let detectionEnabled = true;
        let isDrawing = false; // Для рисования линией
        let lastX = 0, lastY = 0; // Последние координаты для рисования
        
        // Модели
        let hands, faceapi, cocoSsd;
        let modelsLoaded = {
            hands: false,
            faceapi: false,
            cocoSsd: false
        };

        // Переменные для управления состояниями жестов
        let fistCount = 0; // счетчик сжатия кулака
        let gestureActive = false; // режим рисования активен
        let lastFistState = false; // предыдущее состояние кулака (сжат или нет)
        let lastTimeFist = 0; // время последнего изменения состояния для дебаунса

        // Опасные и пищевые объекты для классификации
        const dangerousObjects = ['knife', 'scissors', 'cell phone', 'sports ball'];
        const foodObjects = ['apple', 'banana', 'orange', 'pizza', 'carrot', 'hot dog', 'sandwich', 'cake'];

        // Инициализация приложения
        async function init() {
            try {
                await loadAllModels();
                setupEventListeners();
                await setupCamera();
                resizeCanvases();
                setupDetectors();
                loadingElement.style.display = 'none';
            } catch (error) {
                console.error('Ошибка инициализации:', error);
                loadingStatus.textContent = `Ошибка: ${error.message}`;
            }
        }

        // Загрузка всех моделей
        async function loadAllModels() {
            let totalModels = 3; // MediaPipe, Face-API, COCO-SSD
            let loadedModels = 0;
            
            // Функция обновления прогресса
            function updateProgress() {
                loadedModels++;
                let progress = Math.floor((loadedModels / totalModels) * 100);
                loadingProgress.textContent = `${progress}%`;
            }

            // 1. Инициализация MediaPipe Hands
            loadingStatus.textContent = 'Загрузка модели распознавания рук...';
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            await hands.initialize();
            modelsLoaded.hands = true;
            updateProgress();
            
            // 2. Загрузка моделей Face-API.js
            loadingStatus.textContent = 'Загрузка моделей распознавания лиц...';
            const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
            await Promise.all([
                faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL),
                faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
            ]);
            modelsLoaded.faceapi = true;
            updateProgress();
            
            // 3. Загрузка COCO-SSD
            loadingStatus.textContent = 'Загрузка модели распознавания объектов...';
            cocoSsd = await cocoSsd.load();
            modelsLoaded.cocoSsd = true;
            updateProgress();
            
            loadingStatus.textContent = 'Все модели загружены!';
        }

        // Настройка обработчиков событий
        function setupEventListeners() {
            // Кнопка полноэкранного режима
            fullscreenBtn.addEventListener('click', () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.getElementById('container').requestFullscreen();
                }
            });
            
            // Кнопка переключения камеры
            switchCameraBtn.addEventListener('click', async () => {
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                await setupCamera();
            });
            
            // Переключатель распознавания
            detectionToggleBtn.addEventListener('click', () => {
                detectionEnabled = !detectionEnabled;
                detectionToggleBtn.textContent = `Распознавание ${detectionEnabled ? 'вкл' : 'выкл'}`;
            });
            
            // Обработка изменения размера окна
            window.addEventListener('resize', resizeCanvases);
        }

        // Настройка камеры
        async function setupCamera() {
            if (currentStream) {
                // Остановить предыдущий поток
                currentStream.getTracks().forEach(track => track.stop());
            }
            
            try {
                // Запрос доступа к камере с выбранным режимом
                const constraints = {
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = currentStream;
                
                // Ждем загрузки метаданных видео
                return new Promise((resolve, reject) => {
                    videoElement.onloadedmetadata = () => {
                        // Обновляем размеры канвасов
                        resizeCanvases();
                        
                        // Устанавливаем камеру для MediaPipe
                        if (camera) {
                            camera.stop();
                        }
                        
                        // Инициализация камеры через утилиты Mediapipe
                        camera = new Camera(videoElement, {
                            onFrame: async () => {
                                if (detectionEnabled && modelsLoaded.hands) {
                                    await hands.send({ image: videoElement });
                                }
                            },
                            width: 1280,
                            height: 720
                        });
                        
                        camera.start();
                        resolve();
                    };
                    videoElement.onerror = () => {
                        reject(new Error('Ошибка загрузки видео'));
                    };
                });
            } catch (error) {
                console.error('Ошибка доступа к камере:', error);
                throw error;
            }
        }

        // Изменение размеров canvas под размер окна
        function resizeCanvases() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Устанавливаем размеры для всех канвасов
            [objectsCanvas, facesCanvas, handsCanvas, drawCanvas].forEach(canvas => {
                canvas.width = width;
                canvas.height = height;
            });
            
            // Сбрасываем стили для канваса рисования
            drawCtx.lineJoin = 'round';
            drawCtx.lineCap = 'round';
            drawCtx.lineWidth = 5;
            drawCtx.strokeStyle = 'black';
        }

        // Настройка детекторов
        function setupDetectors() {
            // 1. MediaPipe Hands настройка результатов
            hands.onResults(processHandResults);
            
            // 2. Настройка интервалов для других детекторов 
            // (выполняем менее часто, чем MediaPipe для производительности)
            setInterval(() => {
                if (detectionEnabled) {
                    if (modelsLoaded.faceapi) detectFaces();
                    if (modelsLoaded.cocoSsd) detectObjects();
                }
            }, 100); // Обновляем детекторы каждые 100 мс
        }

        // Функции для определения "сжатости" пальцев
        function isFingerExtended(landmarks, pipIdx, tipIdx) {
            const pip = landmarks[pipIdx];
            const tip = landmarks[tipIdx];
            const wrist = landmarks[0];
            // Евристика: если расстояние от tip до запястья значительно больше, чем от pip до запястья
            const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            const distPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
            return distTip > distPip * 1.3;
        }

        // Проверка жеста "кулак" – все пальцы не вытянуты
        function isFist(landmarks) {
            const fingers = [
                { pip: 6, tip: 8 }, // указательный
                { pip: 10, tip: 12 }, // средний
                { pip: 14, tip: 16 }, // безымянный
                { pip: 18, tip: 20 } // мизинец
            ];
            let thumbExtended = isFingerExtended(landmarks, 2, 4);
            let otherFingersFolded = fingers.every(f => !isFingerExtended(landmarks, f.pip, f.tip));
            return (!thumbExtended) && otherFingersFolded;
        }

        // Проверка жеста "указательный" – указательный палец вытянут, остальные нет
        function isIndexPointing(landmarks) {
            const indexExtended = isFingerExtended(landmarks, 6, 8);
            const otherFingers = [
                { pip: 10, tip: 12 },
                { pip: 14, tip: 16 },
                { pip: 18, tip: 20 }
            ];
            let othersFolded = otherFingers.every(f => !isFingerExtended(landmarks, f.pip, f.tip));
            return indexExtended && othersFolded;
        }

        // Проверка жеста OK – расстояние между большим и указательным пальцами маленькое
        function isOkGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const dx = thumbTip.x - indexTip.x;
            const dy = thumbTip.y - indexTip.y;
            const dist = Math.hypot(dx, dy);
            return dist < 0.05;
        }

        // Обработка результатов от Mediapipe Hands
        function processHandResults(results) {
            handsCtx.clearRect(0, 0, handsCanvas.width, handsCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Вычисляем ограничивающий прямоугольник для руки
                let minX = 1, minY = 1, maxX = 0, maxY = 0;
                landmarks.forEach(pt => {
                    if (pt.x < minX) minX = pt.x;
                    if (pt.y < minY) minY = pt.y;
                    if (pt.x > maxX) maxX = pt.x;
                    if (pt.y > maxY) maxY = pt.y;
                });
                
                // Преобразуем нормированные координаты в координаты canvas
                const boxX = minX * handsCanvas.width;
                const boxY = minY * handsCanvas.height;
                const boxW = (maxX - minX) * handsCanvas.width;
                const boxH = (maxY - minY) * handsCanvas.height;
                
                // Рисуем зелёную рамку
                handsCtx.strokeStyle = 'lime';
                handsCtx.lineWidth = 3;
                handsCtx.strokeRect(boxX, boxY, boxW, boxH);
                
                // Логика распознавания жестов
                const now = Date.now();
                if (now - lastTimeFist > 700) {
                    const fist = isFist(landmarks);
                    if (fist !== lastFistState) {
                        lastFistState = fist;
                        lastTimeFist = now;
                        if (fist) {
                            fistCount++;
                            console.log("Кулак обнаружен. Счёт:", fistCount);
                        }
                    }
                }
                
                if (!gestureActive && fistCount >= 2 && isIndexPointing(landmarks)) {
                    gestureActive = true;
                    console.log("Режим рисования активирован");
                }
                
                if (gestureActive) {
                    const indexTip = landmarks[8];
                    const x = indexTip.x * drawCanvas.width;
                    const y = indexTip.y * drawCanvas.height;
                    
                    // Рисуем линию вместо отдельных точек для более плавного рисования
                    if (!isDrawing) {
                        isDrawing = true;
                        lastX = x;
                        lastY = y;
                    } else {
                        drawCtx.beginPath();
                        drawCtx.moveTo(lastX, lastY);
                        drawCtx.lineTo(x, y);
                        drawCtx.stroke();
                        lastX = x;
                        lastY = y;
                    }
                } else {
                    isDrawing = false;
                }
                
                if (gestureActive && isOkGesture(landmarks)) {
                    console.log("Жест OK обнаружен, очистка холста");
                    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                    gestureActive = false;
                    fistCount = 0;
                }
            } else {
                isDrawing = false;
            }
        }

        // Обнаружение лиц с помощью Face-API.js
        async function detectFaces() {
            if (!videoElement.paused && !videoElement.ended) {
                // Очищаем предыдущие результаты
                facesCtx.clearRect(0, 0, facesCanvas.width, facesCanvas.height);
                
                // Определение лиц с возрастом, полом и эмоциями
                const options = new faceapi.TinyFaceDetectorOptions();
                const displaySize = { width: facesCanvas.width, height: facesCanvas.height };
                
                try {
                    const detections = await faceapi.detectAllFaces(videoElement, options)
                        .withAgeAndGender()
                        .withFaceExpressions();
                        
                    // Изменяем размеры результатов под размер канваса
                    const resizedDetections = faceapi.resizeResults(detections, displaySize);
                    
                    // Обрабатываем каждое обнаруженное лицо
                    resizedDetections.forEach(detection => {
                        const { age, gender, genderProbability } = detection;
                        const expressions = detection.expressions;
                        
                        // Находим доминирующую эмоцию
                        let dominantEmotion = '';
                        let maxProbability = 0;
                        
                        for (const [emotion, probability] of Object.entries(expressions)) {
                            if (probability > maxProbability) {
                                maxProbability = probability;
                                dominantEmotion = emotion;
                            }
                        }
                        
                        // Переводим названия эмоций на русский
                        const emotionTranslations = {
                            'neutral': 'нейтральный',
                            'happy': 'счастливый',
                            'sad': 'грустный',
                            'angry': 'злой',
                            'fearful': 'испуганный',
                            'disgusted': 'отвращение',
                            'surprised': 'удивлённый'
                        };
                        
                        const translatedEmotion = emotionTranslations[dominantEmotion] || dominantEmotion;
                        
                        // Рисуем жёлтую рамку вокруг лица
                        const box = detection.detection.box;
                        facesCtx.strokeStyle = 'yellow';
                        facesCtx.lineWidth = 3;
                        facesCtx.strokeRect(box.x, box.y, box.width, box.height);
                        
                        // Добавляем информацию о возрасте и эмоции
                        facesCtx.font = '16px Arial';
                        facesCtx.fillStyle = 'yellow';
                        facesCtx.fillText(
                            `Возраст: ~${Math.round(age)}, Эмоция: ${translatedEmotion}`,
                            box.x, box.y - 10
                        );
                    });
                } catch (error) {
                    console.error('Ошибка при обнаружении лиц:', error);
                }
            }
        }

        // Обнаружение объектов с помощью COCO-SSD
        async function detectObjects() {
            if (!videoElement.paused && !videoElement.ended) {
                // Очищаем предыдущие результаты
                objectsCtx.clearRect(0, 0, objectsCanvas.width, objectsCanvas.height);
                
                try {
                    // Получаем предсказания
                    const predictions = await cocoSsd.detect(videoElement);
                    
                    // Обрабатываем каждый обнаруженный объект
                    predictions.forEach(prediction => {
                        const [x, y, width, height] = prediction.bbox;
                        const objectClass = prediction.class;
                        
                        // Определяем категорию объекта
                        let color = 'yellow'; // По умолчанию - жёлтый
                        let prefix = '';
                        
                        if (dangerousObjects.includes(objectClass)) {
                            color = 'red';
                            prefix = 'опасный: ';
                        } else if (foodObjects.includes(objectClass)) {
                            color = 'lime';
                            prefix = 'еда: ';
                        }
                        
                        // Рисуем рамку
                        objectsCtx.strokeStyle = color;
                        objectsCtx.lineWidth = 3;
                        objectsCtx.strokeRect(x, y, width, height);
                        
                        // Добавляем фон для текста
                        objectsCtx.fillStyle = `rgba(0, 0, 0, 0.7)`;
                        objectsCtx.fillRect(x, y - 30, width, 30);
                        
                        // Добавляем текст
                        objectsCtx.font = '16px Arial';
                        objectsCtx.fillStyle = color;
                        objectsCtx.fillText(
                            `${prefix}${objectClass} (${Math.round(prediction.score * 100)}%)`,
                            x, y - 10
                        );
                    });
                    
                    // Обновляем список обнаруженных объектов в инфо-панели
                    if (predictions.length > 0) {
                        const detectionsList = predictions.map(p => 
                            `${p.class} (${Math.round(p.score * 100)}%)`
                        ).join(', ');
                        
                        detectionsDiv.innerHTML = `<strong>Обнаружено:</strong> ${detectionsList}`;
                    } else {
                        detectionsDiv.innerHTML = '';
                    }
                } catch (error) {
                    console.error('Ошибка при обнаружении объектов:', error);
                }
            }
        }

        // Запускаем приложение после полной загрузки страницы
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
