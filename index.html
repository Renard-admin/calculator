<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Распознавание жестов, лиц и объектов</title>
<style>
body, html {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #333;
  color: #fff;
  font-family: sans-serif;
}
#container {
  position: relative;
  width: 100vw;
  height: 100vh;
  background: #000;
}
video, canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  /* Зеркальный эффект */
  transform: scaleX(-1);
}
#info {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.7);
  padding: 10px;
  border-radius: 4px;
  z-index: 10;
  max-width: 300px;
}
.controls {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 20;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.btn {
  padding: 10px 15px;
  background: rgba(0, 0, 0, 0.7);
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s;
}
.btn:hover {
  background: rgba(0, 0, 0, 0.9);
}
.status {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(0,0,0,0.7);
  padding: 10px;
  border-radius: 4px;
  z-index: 10;
}
.loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.8);
  padding: 20px;
  border-radius: 8px;
  text-align: center;
  z-index: 100;
}
</style>
</head>
<body>
<div id="container">
  <!-- Видео с камеры -->
  <video id="video" autoplay playsinline muted></video>
  
  <!-- Canvas для отрисовки результатов (рамки) -->
  <canvas id="output"></canvas>
  
  <!-- Слой для рисования линий (чтобы линии не стирались при обновлении видео) -->
  <canvas id="drawLayer"></canvas>
  
  <div id="info">
    <h3>Распознавание и рисование</h3>
    <p><strong>Жесты:</strong></p>
    <ul>
      <li>Два раза сжать/разжать кулак + указательный = начать рисование</li>
      <li>OK (соединить большой и указательный) = очистить</li>
    </ul>
  </div>
  
  <div class="controls">
    <button id="fullscreenBtn" class="btn">Полный экран</button>
    <button id="switchCameraBtn" class="btn">Сменить камеру</button>
  </div>
  
  <div id="status" class="status">Статус: ожидание разрешений...</div>
  
  <div id="loading" class="loading">
    <h2>Загрузка моделей...</h2>
    <p id="loadingStatus">Подготовка...</p>
  </div>
</div>

<!-- Подключение библиотек -->
<!-- Mediapipe для рук -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<!-- Face-api.js для распознавания лиц -->
<script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>

<!-- TensorFlow.js и COCO-SSD для обнаружения объектов -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

<script>
// Элементы страницы
const videoElement = document.getElementById('video');
const outputCanvas = document.getElementById('output');
const drawCanvas = document.getElementById('drawLayer');
const statusDiv = document.getElementById('status');
const loadingDiv = document.getElementById('loading');
const loadingStatus = document.getElementById('loadingStatus');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const switchCameraBtn = document.getElementById('switchCameraBtn');
const outputCtx = outputCanvas.getContext('2d');
const drawCtx = drawCanvas.getContext('2d');

// Переменные состояния
let camera = null;
let hands = null;
let faceApiReady = false;
let cocoModelReady = false;
let cocoModel = null;
let facingMode = 'user'; // По умолчанию фронтальная камера
let streaming = false;
let drawingMode = false;
let lastX = 0, lastY = 0;

// Переменные для жестов
let fistCount = 0;
let gestureActive = false;
let lastFistState = false;
let lastTimeFist = 0;

// Изменяем размеры canvas под размер окна
function resizeCanvases() {
  outputCanvas.width = videoElement.videoWidth || window.innerWidth;
  outputCanvas.height = videoElement.videoHeight || window.innerHeight;
  drawCanvas.width = outputCanvas.width;
  drawCanvas.height = outputCanvas.height;
}

// Загрузка моделей face-api.js
async function loadFaceApiModels() {
  loadingStatus.textContent = 'Загрузка моделей для распознавания лиц...';
  
  await Promise.all([
    faceapi.nets.tinyFaceDetector.loadFromUri('https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights'),
    faceapi.nets.ageGenderNet.loadFromUri('https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights'),
    faceapi.nets.faceExpressionNet.loadFromUri('https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/weights')
  ]);
  
  faceApiReady = true;
  return true;
}

// Загрузка модели COCO-SSD
async function loadCocoSsdModel() {
  loadingStatus.textContent = 'Загрузка моделей для распознавания объектов...';
  cocoModel = await cocoSSD.load();
  cocoModelReady = true;
  return true;
}

// Инициализация MediaPipe Hands
function initHandsModel() {
  loadingStatus.textContent = 'Инициализация модели для распознавания рук...';
  
  hands = new Hands({
    locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }
  });
  
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });
  
  hands.onResults(onHandsResults);
  return true;
}

// Инициализация камеры
async function initCamera() {
  try {
    const constraints = {
      video: {
        facingMode: facingMode,
        width: { ideal: 1280 },
        height: { ideal: 720 }
      }
    };
    
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoElement.srcObject = stream;
    
    return new Promise((resolve) => {
      videoElement.onloadedmetadata = () => {
        resizeCanvases();
        streaming = true;
        statusDiv.textContent = 'Статус: камера работает';
        resolve(true);
      };
    });
  } catch (error) {
    console.error('Ошибка доступа к камере:', error);
    statusDiv.textContent = 'Статус: ошибка доступа к камере';
    return false;
  }
}

// Переключение камеры (передняя/задняя)
async function switchCamera() {
  if (camera) {
    camera.stop();
  }
  
  if (videoElement.srcObject) {
    const tracks = videoElement.srcObject.getTracks();
    tracks.forEach(track => track.stop());
  }
  
  facingMode = facingMode === 'user' ? 'environment' : 'user';
  await initCamera();
  startCamera();
}

// Запуск обработки видео с камеры
function startCamera() {
  if (camera) {
    camera.stop();
  }
  
  camera = new Camera(videoElement, {
    onFrame: async () => {
      await hands.send({ image: videoElement });
      detectFaces();
      detectObjects();
    },
    width: 1280,
    height: 720
  });
  
  camera.start();
}

// Функции для определения жестов
function isFingerExtended(landmarks, pipIdx, tipIdx) {
  const pip = landmarks[pipIdx];
  const tip = landmarks[tipIdx];
  const wrist = landmarks[0];
  const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
  const distPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
  return distTip > distPip * 1.3;
}

function isFist(landmarks) {
  const fingers = [
    { pip: 6, tip: 8 },   // указательный
    { pip: 10, tip: 12 }, // средний
    { pip: 14, tip: 16 }, // безымянный
    { pip: 18, tip: 20 }  // мизинец
  ];
  let thumbExtended = isFingerExtended(landmarks, 2, 4);
  let otherFingersFolded = fingers.every(f => !isFingerExtended(landmarks, f.pip, f.tip));
  return (!thumbExtended) && otherFingersFolded;
}

function isIndexPointing(landmarks) {
  const indexExtended = isFingerExtended(landmarks, 6, 8);
  const otherFingers = [
    { pip: 10, tip: 12 },
    { pip: 14, tip: 16 },
    { pip: 18, tip: 20 }
  ];
  let othersFolded = otherFingers.every(f => !isFingerExtended(landmarks, f.pip, f.tip));
  return indexExtended && othersFolded;
}

function isOkGesture(landmarks) {
  const thumbTip = landmarks[4];
  const indexTip = landmarks[8];
  const dist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
  return dist < 0.05;
}

// Обработка результатов от MediaPipe Hands
function onHandsResults(results) {
  if (!results.multiHandLandmarks) return;
  
  // Очищаем canvas для новой отрисовки
  outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
  
  // Отрисовываем видео-кадр на canvas
  outputCtx.save();
  outputCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
  
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    const landmarks = results.multiHandLandmarks[0];
    
    // Вычисляем ограничивающий прямоугольник для руки
    let minX = 1, minY = 1, maxX = 0, maxY = 0;
    landmarks.forEach(pt => {
      if (pt.x < minX) minX = pt.x;
      if (pt.y < minY) minY = pt.y;
      if (pt.x > maxX) maxX = pt.x;
      if (pt.y > maxY) maxY = pt.y;
    });
    
    // Преобразуем нормированные координаты в координаты canvas
    const boxX = minX * outputCanvas.width;
    const boxY = minY * outputCanvas.height;
    const boxW = (maxX - minX) * outputCanvas.width;
    const boxH = (maxY - minY) * outputCanvas.height;
    
    // Рисуем зелёную рамку
    outputCtx.strokeStyle = 'lime';
    outputCtx.lineWidth = 3;
    outputCtx.strokeRect(boxX, boxY, boxW, boxH);
    
    // Логика распознавания жестов
    const now = Date.now();
    if (now - lastTimeFist > 700) {
      const fist = isFist(landmarks);
      if (fist !== lastFistState) {
        lastFistState = fist;
        lastTimeFist = now;
        if (fist) {
          fistCount++;
          console.log("Кулак обнаружен. Счёт:", fistCount);
        }
      }
    }
    
    // Активация режима рисования
    if (!gestureActive && fistCount >= 2 && isIndexPointing(landmarks)) {
      gestureActive = true;
      console.log("Режим рисования активирован");
      statusDiv.textContent = 'Статус: режим рисования активен';
    }
    
    // Рисование в режиме рисования
    if (gestureActive) {
      const indexTip = landmarks[8];
      const x = indexTip.x * drawCanvas.width;
      const y = indexTip.y * drawCanvas.height;
      
      drawCtx.lineWidth = 4;
      drawCtx.lineCap = 'round';
      drawCtx.strokeStyle = 'black';
      
      if (drawingMode) {
        drawCtx.beginPath();
        drawCtx.moveTo(lastX, lastY);
        drawCtx.lineTo(x, y);
        drawCtx.stroke();
      }
      
      lastX = x;
      lastY = y;
      drawingMode = true;
    } else {
      drawingMode = false;
    }
    
    // Очистка холста по жесту OK
    if (gestureActive && isOkGesture(landmarks)) {
      console.log("Жест OK обнаружен, очистка холста");
      drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      gestureActive = false;
      fistCount = 0;
      statusDiv.textContent = 'Статус: холст очищен';
    }
  }
  
  outputCtx.restore();
}

// Распознавание лиц с face-api.js
async function detectFaces() {
  if (!faceApiReady || !streaming) return;
  
  try {
    // Получение детекций с face-api
    const detections = await faceapi.detectAllFaces(videoElement, new faceapi.TinyFaceDetectorOptions())
      .withAgeAndGender()
      .withFaceExpressions();
    
    if (!detections || detections.length === 0) return;
    
    // Для каждого обнаруженного лица
    detections.forEach(detection => {
      const box = detection.detection.box;
      // Рисуем жёлтую рамку вокруг лица
      outputCtx.strokeStyle = 'yellow';
      outputCtx.lineWidth = 2;
      outputCtx.strokeRect(box.x, box.y, box.width, box.height);
      
      // Получаем эмоции и возраст
      const age = Math.round(detection.age);
      
      // Находим доминирующую эмоцию
      let dominantEmotion = '';
      let maxScore = 0;
      for (const [emotion, score] of Object.entries(detection.expressions)) {
        if (score > maxScore) {
          maxScore = score;
          dominantEmotion = emotion;
        }
      }
      
      // Преобразуем название эмоции в русское
      const emotionRussian = {
        'neutral': 'нейтральный',
        'happy': 'счастливый',
        'sad': 'грустный',
        'angry': 'злой',
        'fearful': 'испуганный',
        'disgusted': 'отвращение',
        'surprised': 'удивлённый'
      };
      
      // Рисуем фон для текста
      outputCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      outputCtx.fillRect(box.x, box.y - 40, box.width, 40);
      
      // Выводим возраст и эмоцию
      outputCtx.fillStyle = 'white';
      outputCtx.font = '16px Arial';
      outputCtx.fillText(
        `Возраст: ~${age}, ${emotionRussian[dominantEmotion] || dominantEmotion}`,
        box.x + 5, box.y - 15
      );
    });
  } catch (error) {
    console.error('Ошибка при обнаружении лиц:', error);
  }
}

// Распознавание объектов с COCO-SSD
async function detectObjects() {
  if (!cocoModelReady || !streaming) return;
  
  try {
    const predictions = await cocoModel.detect(videoElement);
    
    if (!predictions || predictions.length === 0) return;
    
    // Списки опасных объектов и еды
    const dangerousObjects = ['knife', 'scissors', 'fork', 'gun', 'baseball bat', 'fire hydrant'];
    const foodObjects = ['apple', 'banana', 'orange', 'pizza', 'cake', 'donut', 'sandwich', 'hot dog', 'carrot', 'broccoli'];
    
    // Словарь для перевода классов объектов
    const objectTranslations = {
      'person': 'человек',
      'bicycle': 'велосипед',
      'car': 'автомобиль',
      'motorcycle': 'мотоцикл',
      'airplane': 'самолёт',
      'bus': 'автобус',
      'train': 'поезд',
      'truck': 'грузовик',
      'boat': 'лодка',
      'traffic light': 'светофор',
      'fire hydrant': 'пожарный гидрант',
      'stop sign': 'знак остановки',
      'parking meter': 'парковочный счётчик',
      'bench': 'скамейка',
      'bird': 'птица',
      'cat': 'кошка',
      'dog': 'собака',
      'horse': 'лошадь',
      'sheep': 'овца',
      'cow': 'корова',
      'elephant': 'слон',
      'bear': 'медведь',
      'zebra': 'зебра',
      'giraffe': 'жираф',
      'backpack': 'рюкзак',
      'umbrella': 'зонт',
      'handbag': 'сумочка',
      'tie': 'галстук',
      'suitcase': 'чемодан',
      'frisbee': 'фрисби',
      'skis': 'лыжи',
      'snowboard': 'сноуборд',
      'sports ball': 'спортивный мяч',
      'kite': 'воздушный змей',
      'baseball bat': 'бейсбольная бита',
      'baseball glove': 'бейсбольная перчатка',
      'skateboard': 'скейтборд',
      'surfboard': 'доска для серфинга',
      'tennis racket': 'теннисная ракетка',
      'bottle': 'бутылка',
      'wine glass': 'бокал вина',
      'cup': 'чашка',
      'fork': 'вилка',
      'knife': 'нож',
      'spoon': 'ложка',
      'bowl': 'миска',
      'banana': 'банан',
      'apple': 'яблоко',
      'sandwich': 'бутерброд',
      'orange': 'апельсин',
      'broccoli': 'брокколи',
      'carrot': 'морковь',
      'hot dog': 'хот-дог',
      'pizza': 'пицца',
      'donut': 'пончик',
      'cake': 'торт',
      'chair': 'стул',
      'couch': 'диван',
      'potted plant': 'комнатное растение',
      'bed': 'кровать',
      'dining table': 'обеденный стол',
      'toilet': 'туалет',
      'tv': 'телевизор',
      'laptop': 'ноутбук',
      'mouse': 'мышь',
      'remote': 'пульт',
      'keyboard': 'клавиатура',
      'cell phone': 'мобильный телефон',
      'microwave': 'микроволновка',
      'oven': 'духовка',
      'toaster': 'тостер',
      'sink': 'раковина',
      'refrigerator': 'холодильник',
      'book': 'книга',
      'clock': 'часы',
      'vase': 'ваза',
      'scissors': 'ножницы',
      'teddy bear': 'плюшевый мишка',
      'hair drier': 'фен',
      'toothbrush': 'зубная щётка',
      'gun': 'пистолет'
    };
    
    // Отрисовываем каждое предсказание
    predictions.forEach(prediction => {
      const { bbox, class: objectClass, score } = prediction;
      const [x, y, width, height] = bbox;
      
      // Категоризация объекта
      let color = 'yellow'; // По умолчанию желтый
      let prefix = '';
      
      if (dangerousObjects.includes(objectClass)) {
        color = 'red';
        prefix = 'опасный: ';
      } else if (foodObjects.includes(objectClass)) {
        color = 'green';
        prefix = 'еда: ';
      }
      
      // Отрисовка рамки
      outputCtx.strokeStyle = color;
      outputCtx.lineWidth = 3;
      outputCtx.strokeRect(x, y, width, height);
      
      // Фон для текста
      outputCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      outputCtx.fillRect(x, y - 25, width, 25);
      
      // Отрисовка текста
      outputCtx.fillStyle = 'white';
      outputCtx.font = '14px Arial';
      
      // Переведенное название объекта или оригинальное, если перевода нет
      const translatedName = objectTranslations[objectClass] || objectClass;
      outputCtx.fillText(
        `${prefix}${translatedName} (${Math.round(score * 100)}%)`,
        x + 5, y - 7
      );
    });
  } catch (error) {
    console.error('Ошибка при обнаружении объектов:', error);
  }
}

// Начальная инициализация
async function init() {
  window.addEventListener('resize', resizeCanvases);
  
  // Кнопка полноэкранного режима
  fullscreenBtn.addEventListener('click', () => {
    if (document.fullscreenElement) {
      document.exitFullscreen();
    } else {
      document.getElementById('container').requestFullscreen();
    }
  });
  
  // Кнопка переключения камеры
  switchCameraBtn.addEventListener('click', switchCamera);
  
  try {
    // Инициализация всех моделей параллельно
    const [cameraInitialized, handsInitialized, faceApiInitialized, cocoInitialized] = await Promise.all([
      initCamera(),
      initHandsModel(),
      loadFaceApiModels(),
      loadCocoSsdModel()
    ]);
    
    if (cameraInitialized && handsInitialized && faceApiInitialized && cocoInitialized) {
      loadingDiv.style.display = 'none';
      statusDiv.textContent = 'Статус: все модели загружены, камера работает';
      startCamera();
    } else {
      statusDiv.textContent = 'Статус: ошибка инициализации';
    }
  } catch (error) {
    console.error('Ошибка инициализации:', error);
    statusDiv.textContent = 'Статус: ошибка инициализации - ' + error.message;
  }
}

// Запуск приложения
window.onload = init;
</script>
</body>
</html>
