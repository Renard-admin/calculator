<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Лазерное рисование</title>
  <style>
    /* Сброс отступов и настройка размеров */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      height: 100%;
    }
    /* Видео занимает весь экран */
    #video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 1;
    }
    /* Canvas для рисования поверх видео */
    #drawingCanvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 2;
    }
    /* Кнопка выбора цвета в правом верхнем углу */
    #colorPickerButton {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 3;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    /* Скрытый input для выбора цвета */
    #colorPicker {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Видео с камеры -->
  <video id="video" autoplay playsinline></video>
  <!-- Canvas для рисования -->
  <canvas id="drawingCanvas"></canvas>
  <!-- Кнопка выбора цвета -->
  <button id="colorPickerButton">Цвет линии</button>
  <input type="color" id="colorPicker">

  <script>
    // Получение элементов
    const video = document.getElementById('video');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const ctx = drawingCanvas.getContext('2d');
    const colorPickerButton = document.getElementById('colorPickerButton');
    const colorPicker = document.getElementById('colorPicker');

    // Настройки рисования
    let drawingColor = "#ff0000"; // базовый цвет лазера – красный
    let mode = "draw"; // режим: "draw" (рисование) или "erase" (ластик)
    let toggleCount = 0; // счетчик переключений (лазер включен/выключен)
    let previousLaserDetected = false; // предыдущее состояние обнаружения лазера
    let lastPos = null; // предыдущая координата для рисования линий

    // Для обработки кадров видео создаем скрытый canvas
    const processingCanvas = document.createElement('canvas');
    const procCtx = processingCanvas.getContext('2d');

    // Запрос к камере: предпочтительно задняя (environment)
    navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: "environment" } },
      audio: false
    }).then(stream => {
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        // Устанавливаем размеры canvas в соответствии с видео (можно брать размеры окна)
        const width = window.innerWidth;
        const height = window.innerHeight;
        drawingCanvas.width = width;
        drawingCanvas.height = height;
        processingCanvas.width = width;
        processingCanvas.height = height;
        // Начинаем обработку кадров
        requestAnimationFrame(processFrame);
      };
    }).catch(err => {
      console.error("Ошибка доступа к камере: ", err);
      alert("Не удалось получить доступ к камере.");
    });

    // Логика выбора цвета через кнопку
    colorPickerButton.addEventListener('click', () => {
      colorPicker.click();
    });

    colorPicker.addEventListener('change', (event) => {
      drawingColor = event.target.value;
    });

    /**
     * Обработка каждого кадра видео:
     * – копируем текущий кадр в скрытый canvas,
     * – ищем яркие красные области (лазорный луч),
     * – если точка найдена, рисуем линию между точками,
     * – отслеживаем переключения (отсутствие и присутствие лазера) для смены режима.
     */
    function processFrame() {
      // Рисуем текущий кадр из видео на processingCanvas
      procCtx.drawImage(video, 0, 0, processingCanvas.width, processingCanvas.height);
      const frame = procCtx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);
      const data = frame.data;

      let sumX = 0, sumY = 0, count = 0;
      // Пробегаемся по пикселям с шагом (например, 5 пикселей для ускорения)
      for (let y = 0; y < processingCanvas.height; y += 5) {
        for (let x = 0; x < processingCanvas.width; x += 5) {
          const index = (y * processingCanvas.width + x) * 4;
          const r = data[index], g = data[index + 1], b = data[index + 2];
          // Простая фильтрация: если красный канал очень высокий и значительно превосходит зеленый и синий
          if (r > 200 && r > g + 50 && r > b + 50) {
            sumX += x;
            sumY += y;
            count++;
          }
        }
      }

      let laserDetected = count > 0;
      let pos = null;
      if (laserDetected) {
        pos = { x: sumX / count, y: sumY / count };
      }

      // Если лазер ранее был обнаружен, а теперь его нет – считаем переключение
      if (previousLaserDetected && !laserDetected) {
        toggleCount++;
        // Если переключили 3 раза, меняем режим (рисование <-> ластик)
        if (toggleCount >= 3) {
          mode = (mode === "draw") ? "erase" : "draw";
          console.log("Режим переключён на:", mode);
          toggleCount = 0;
        }
      }
      previousLaserDetected = laserDetected;

      // Если обнаружена позиция лазера, рисуем линию (сглаживание посредством интерполяции между предыдущей и текущей координатой)
      if (pos) {
        ctx.lineWidth = 5;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        // В режиме "erase" рисуем белой линией (при условии что фон белый или можем очистить участок)
        ctx.strokeStyle = (mode === "draw") ? drawingColor : "#ffffff";

        ctx.beginPath();
        if (lastPos) {
          // Рисуем линию от предыдущей до текущей позиции
          ctx.moveTo(lastPos.x, lastPos.y);
        } else {
          ctx.moveTo(pos.x, pos.y);
        }
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        lastPos = pos;
      } else {
        // Если лазер не обнаружен – сбрасываем предыдущую позицию, чтобы избежать линии при повторном появлении
        lastPos = null;
      }

      // Рекурсивный вызов для следующего кадра
      requestAnimationFrame(processFrame);
    }
  </script>
</body>
</html>
